{"mappings":"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","sources":["<anon>","src/routes/blog/2020-12-13-multiplayer-tetris-game-part-1/embed-poc/src/index.mjs"],"sourcesContent":["var $9506314bc53e323e$exports = {};\nconst $9506314bc53e323e$var$SHAPE_TYPES = [\n    [\n        [\n            1,\n            1\n        ],\n        [\n            1,\n            1\n        ]\n    ],\n    [\n        [\n            1,\n            0,\n            0\n        ],\n        [\n            1,\n            1,\n            1\n        ]\n    ],\n    [\n        [\n            0,\n            1,\n            0\n        ],\n        [\n            1,\n            1,\n            1\n        ]\n    ],\n    [\n        [\n            1,\n            1,\n            1\n        ]\n    ]\n];\nconst $9506314bc53e323e$var$ACTION_TYPES = {\n    moveLeft: (shape)=>{\n        shape.x--;\n    },\n    moveRight: (shape)=>{\n        shape.x++;\n    },\n    moveDown: (shape)=>{\n        shape.y++;\n    },\n    rotateShape: (shape)=>{\n        const type = [];\n        for(let i = 0; i < shape.type[0].length; ++i){\n            type[i] = [];\n            for(let j = 0; j < shape.type.length; ++j)type[i][j] = shape.type[shape.type.length - 1 - j][i];\n        }\n        shape.type = type;\n    }\n};\nconst $9506314bc53e323e$var$RULE_ACTIONS = {\n    BLOCK_ACTION: 1,\n    CREATE_SHAPE: 2,\n    END_THE_GAME: 3\n};\nconst $9506314bc53e323e$var$startPlayer = (keymap, listener)=>{\n    const keyDownListener = (e)=>{\n        for (const key of Object.keys(keymap))if (e.code === key) {\n            listener(keymap[key]);\n            break;\n        }\n    };\n    document.addEventListener('keydown', keyDownListener);\n    return ()=>{\n        document.removeEventListener('keydown', keyDownListener);\n    };\n};\nconst $9506314bc53e323e$var$startWorld = (keymaps, renderer, ticker, ruleset, options)=>{\n    const PLAYER_COLORS = [\n        '#6fa8dc',\n        '#f6b26b'\n    ];\n    const playersCount = keymaps.length;\n    const playerShapes = [];\n    const stopPlayerFns = [];\n    const requestReRender = ()=>{\n        renderer(playerShapes);\n    };\n    const createNewShape = (i)=>{\n        const index = Math.floor(Math.random() * $9506314bc53e323e$var$SHAPE_TYPES.length);\n        const shape = {\n            x: 0,\n            y: 0,\n            type: $9506314bc53e323e$var$SHAPE_TYPES[index],\n            color: '#111'\n        };\n        shape.x = Math.floor(options.worldWidth / playersCount / 2 * (i * 2 + 1));\n        shape.y = -shape.type.length;\n        shape.color = PLAYER_COLORS[i % PLAYER_COLORS.length];\n        playerShapes[i].unshift(shape);\n        requestReRender();\n    };\n    const playerActionListener = (i, action)=>{\n        const activeShape = playerShapes[i][0];\n        const simulated = Object.create(activeShape);\n        action(simulated);\n        for(let j = 0; j < ruleset.length; ++j){\n            const ruleFn = ruleset[j];\n            const result = ruleFn(simulated, activeShape, playerShapes);\n            if (result === $9506314bc53e323e$var$RULE_ACTIONS.BLOCK_ACTION) return;\n            else if (result === $9506314bc53e323e$var$RULE_ACTIONS.CREATE_SHAPE) {\n                createNewShape(i);\n                return;\n            } else if (result === $9506314bc53e323e$var$RULE_ACTIONS.END_THE_GAME) {\n                alert('GAME OVER!');\n                stopWorld();\n            }\n        }\n        action(activeShape);\n        requestReRender();\n    };\n    const stopGameClock = ticker(()=>{\n        for(let i = 0; i < playerShapes.length; ++i)playerActionListener(i, $9506314bc53e323e$var$ACTION_TYPES.moveDown);\n    });\n    const stopWorld = ()=>{\n        stopGameClock();\n        stopPlayerFns.forEach((fn)=>fn());\n    };\n    for(let i = 0; i < playersCount; ++i){\n        playerShapes[i] = [];\n        createNewShape(i);\n    }\n    for(let i = 0; i < playersCount; ++i){\n        const keymap = keymaps[i];\n        const listener = (action)=>playerActionListener(i, action);\n        stopPlayerFns[i] = $9506314bc53e323e$var$startPlayer(keymap, listener);\n    }\n    return stopWorld;\n};\nconst $9506314bc53e323e$var$createRenderer = (canvas, options)=>{\n    const canvasWidth = options.worldWidth * options.worldScale;\n    const canvasHeight = options.worldHeight * options.worldScale;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    const ctx = canvas.getContext('2d');\n    const renderBlock = (x, y, color)=>{\n        ctx.fillStyle = color;\n        ctx.strokeStyle = '#000';\n        ctx.fillRect(x * options.worldScale, y * options.worldScale, options.worldScale, options.worldScale);\n        ctx.strokeRect(x * options.worldScale, y * options.worldScale, options.worldScale, options.worldScale);\n    };\n    const renderShape = (shape)=>{\n        ctx.save();\n        ctx.translate(shape.x * options.worldScale, shape.y * options.worldScale);\n        for(let i = 0; i < shape.type.length; ++i){\n            const row = shape.type[i];\n            for(let j = 0; j < row.length; ++j)if (row[j]) renderBlock(j, i, shape.color);\n        }\n        ctx.restore();\n    };\n    return (playerShapes)=>{\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        for(let i = 0; i < playerShapes.length; ++i){\n            const shapes = playerShapes[i];\n            for(let j = 0; j < shapes.length; ++j)renderShape(shapes[j]);\n        }\n    };\n};\nconst $9506314bc53e323e$var$createTicker = (t)=>{\n    return (fn)=>{\n        let enabled = true;\n        const handler = ()=>{\n            if (!enabled) return;\n            fn();\n            setTimeout(handler, t);\n        };\n        setTimeout(handler, t);\n        return ()=>{\n            enabled = false;\n        };\n    };\n};\nconst $9506314bc53e323e$var$createGameRules = (options)=>{\n    const doesBBoxOverlap = (s1, s2)=>{\n        if (s1.x > s2.x + s2.type[0].length || s1.x + s1.type[0].length < s2.x || s1.y > s2.y + s2.type.length || s1.y + s1.type.length < s2.y) return false;\n        return true;\n    };\n    const doesBlockOverlap = (s1, row, col, s2)=>{\n        if (!s1.type[row][col]) return false;\n        const s2row = row + s1.y - s2.y;\n        const s2col = col + s1.x - s2.x;\n        if (s2.type[s2row] && s2.type[s2row][s2col]) return true;\n        return false;\n    };\n    const getOtherShapes = function*(activeShape, playerShapes) {\n        for(let i = 0; i < playerShapes.length; ++i){\n            const shapes = playerShapes[i];\n            for(let j = 0; j < shapes.length; ++j){\n                const shape = shapes[j];\n                if (shape === activeShape) continue;\n                yield [\n                    shape,\n                    j === 0\n                ];\n            }\n        }\n    };\n    const isBlockedFromLeft = (simulated, activeShape, playerShapes)=>{\n        if (simulated.type === activeShape.type && simulated.x >= activeShape.x) return null;\n        if (simulated.x < 0) return $9506314bc53e323e$var$RULE_ACTIONS.BLOCK_ACTION;\n        for (let [shape] of getOtherShapes(activeShape, playerShapes)){\n            if (!doesBBoxOverlap(simulated, shape)) continue;\n            const col = 0;\n            for(let row = 0; row < simulated.type.length; ++row){\n                if (doesBlockOverlap(simulated, row, col, shape)) return $9506314bc53e323e$var$RULE_ACTIONS.BLOCK_ACTION;\n            }\n        }\n        return null;\n    };\n    const isBlockedFromRight = (simulated, activeShape, playerShapes)=>{\n        if (simulated.type === activeShape.type && simulated.x <= activeShape.x) return null;\n        if (simulated.x + simulated.type[0].length > options.worldWidth) return $9506314bc53e323e$var$RULE_ACTIONS.BLOCK_ACTION;\n        for (let [shape] of getOtherShapes(activeShape, playerShapes)){\n            if (!doesBBoxOverlap(simulated, shape)) continue;\n            const col = simulated.type[0].length - 1;\n            for(let row = 0; row < simulated.type.length; ++row){\n                if (doesBlockOverlap(simulated, row, col, shape)) return $9506314bc53e323e$var$RULE_ACTIONS.BLOCK_ACTION;\n            }\n        }\n        return null;\n    };\n    const isBlockedFromBottom = (simulated, activeShape, playerShapes)=>{\n        if (simulated.type === activeShape.type && simulated.y <= activeShape.y) return null;\n        if (simulated.y + simulated.type.length > options.worldHeight) return $9506314bc53e323e$var$RULE_ACTIONS.CREATE_SHAPE;\n        for (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)){\n            if (!doesBBoxOverlap(simulated, shape)) continue;\n            const row = simulated.type.length - 1;\n            for(let col = 0; col < simulated.type[0].length; ++col)if (doesBlockOverlap(simulated, row, col, shape)) {\n                if (simulated.y <= 0) return $9506314bc53e323e$var$RULE_ACTIONS.END_THE_GAME;\n                if (isActive) return $9506314bc53e323e$var$RULE_ACTIONS.BLOCK_ACTION;\n                return $9506314bc53e323e$var$RULE_ACTIONS.CREATE_SHAPE;\n            }\n        }\n        return null;\n    };\n    return [\n        isBlockedFromLeft,\n        isBlockedFromRight,\n        isBlockedFromBottom\n    ];\n};\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    const keymaps = [\n        {\n            KeyW: $9506314bc53e323e$var$ACTION_TYPES.rotateShape,\n            KeyA: $9506314bc53e323e$var$ACTION_TYPES.moveLeft,\n            KeyS: $9506314bc53e323e$var$ACTION_TYPES.moveDown,\n            KeyD: $9506314bc53e323e$var$ACTION_TYPES.moveRight\n        },\n        {\n            ArrowUp: $9506314bc53e323e$var$ACTION_TYPES.rotateShape,\n            ArrowLeft: $9506314bc53e323e$var$ACTION_TYPES.moveLeft,\n            ArrowDown: $9506314bc53e323e$var$ACTION_TYPES.moveDown,\n            ArrowRight: $9506314bc53e323e$var$ACTION_TYPES.moveRight\n        }\n    ];\n    const options = {\n        worldWidth: 32,\n        worldHeight: 16,\n        worldScale: 25\n    };\n    const canvas = document.getElementById('game-canvas');\n    const renderer = $9506314bc53e323e$var$createRenderer(canvas, options);\n    const ticker = $9506314bc53e323e$var$createTicker(500);\n    const ruleset = $9506314bc53e323e$var$createGameRules(options);\n    $9506314bc53e323e$var$startWorld(keymaps, renderer, ticker, ruleset, options);\n});\n\n\n//# sourceMappingURL=embed-poc.1791db91.js.map\n","const SHAPE_TYPES = [\n\t[\n\t\t[1, 1],\n\t\t[1, 1]\n\t],\n\t[\n\t\t[1, 0, 0],\n\t\t[1, 1, 1]\n\t],\n\t[\n\t\t[0, 1, 0],\n\t\t[1, 1, 1]\n\t],\n\t[[1, 1, 1]]\n];\n\nconst ACTION_TYPES = {\n\tmoveLeft: (shape) => {\n\t\tshape.x--;\n\t},\n\n\tmoveRight: (shape) => {\n\t\tshape.x++;\n\t},\n\n\tmoveDown: (shape) => {\n\t\tshape.y++;\n\t},\n\n\trotateShape: (shape) => {\n\t\tconst type = [];\n\t\tfor (let i = 0; i < shape.type[0].length; ++i) {\n\t\t\ttype[i] = [];\n\t\t\tfor (let j = 0; j < shape.type.length; ++j) {\n\t\t\t\ttype[i][j] = shape.type[shape.type.length - 1 - j][i];\n\t\t\t}\n\t\t}\n\t\tshape.type = type;\n\t}\n};\n\nconst RULE_ACTIONS = {\n\tBLOCK_ACTION: 1,\n\tCREATE_SHAPE: 2,\n\tEND_THE_GAME: 3\n};\n\nconst startPlayer = (keymap, listener) => {\n\tconst keyDownListener = (e) => {\n\t\tfor (const key of Object.keys(keymap)) {\n\t\t\tif (e.code === key) {\n\t\t\t\tlistener(keymap[key]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\tdocument.addEventListener('keydown', keyDownListener);\n\n\treturn () => {\n\t\tdocument.removeEventListener('keydown', keyDownListener);\n\t};\n};\n\nconst startWorld = (keymaps, renderer, ticker, ruleset, options) => {\n\tconst PLAYER_COLORS = ['#6fa8dc', '#f6b26b'];\n\tconst playersCount = keymaps.length;\n\tconst playerShapes = [];\n\tconst stopPlayerFns = [];\n\tconst requestReRender = () => {\n\t\trenderer(playerShapes);\n\t};\n\tconst createNewShape = (i) => {\n\t\tconst index = Math.floor(Math.random() * SHAPE_TYPES.length);\n\t\tconst shape = { x: 0, y: 0, type: SHAPE_TYPES[index], color: '#111' };\n\t\tshape.x = Math.floor((options.worldWidth / playersCount / 2) * (i * 2 + 1));\n\t\tshape.y = -shape.type.length;\n\t\tshape.color = PLAYER_COLORS[i % PLAYER_COLORS.length];\n\t\tplayerShapes[i].unshift(shape);\n\t\trequestReRender();\n\t};\n\tconst playerActionListener = (i, action) => {\n\t\tconst activeShape = playerShapes[i][0];\n\t\tconst simulated = Object.create(activeShape);\n\t\taction(simulated);\n\t\tfor (let j = 0; j < ruleset.length; ++j) {\n\t\t\tconst ruleFn = ruleset[j];\n\t\t\tconst result = ruleFn(simulated, activeShape, playerShapes);\n\t\t\tif (result === RULE_ACTIONS.BLOCK_ACTION) {\n\t\t\t\treturn;\n\t\t\t} else if (result === RULE_ACTIONS.CREATE_SHAPE) {\n\t\t\t\tcreateNewShape(i);\n\t\t\t\treturn;\n\t\t\t} else if (result === RULE_ACTIONS.END_THE_GAME) {\n\t\t\t\talert('GAME OVER!');\n\t\t\t\tstopWorld();\n\t\t\t}\n\t\t}\n\t\taction(activeShape);\n\t\trequestReRender();\n\t};\n\tconst stopGameClock = ticker(() => {\n\t\tfor (let i = 0; i < playerShapes.length; ++i) {\n\t\t\tplayerActionListener(i, ACTION_TYPES.moveDown);\n\t\t}\n\t});\n\tconst stopWorld = () => {\n\t\tstopGameClock();\n\t\tstopPlayerFns.forEach((fn) => fn());\n\t};\n\tfor (let i = 0; i < playersCount; ++i) {\n\t\tplayerShapes[i] = [];\n\t\tcreateNewShape(i);\n\t}\n\tfor (let i = 0; i < playersCount; ++i) {\n\t\tconst keymap = keymaps[i];\n\t\tconst listener = (action) => playerActionListener(i, action);\n\t\tstopPlayerFns[i] = startPlayer(keymap, listener);\n\t}\n\n\treturn stopWorld;\n};\n\nconst createRenderer = (canvas, options) => {\n\tconst canvasWidth = options.worldWidth * options.worldScale;\n\tconst canvasHeight = options.worldHeight * options.worldScale;\n\tcanvas.width = canvasWidth;\n\tcanvas.height = canvasHeight;\n\tconst ctx = canvas.getContext('2d');\n\n\tconst renderBlock = (x, y, color) => {\n\t\tctx.fillStyle = color;\n\t\tctx.strokeStyle = '#000';\n\t\tctx.fillRect(\n\t\t\tx * options.worldScale,\n\t\t\ty * options.worldScale,\n\t\t\toptions.worldScale,\n\t\t\toptions.worldScale\n\t\t);\n\t\tctx.strokeRect(\n\t\t\tx * options.worldScale,\n\t\t\ty * options.worldScale,\n\t\t\toptions.worldScale,\n\t\t\toptions.worldScale\n\t\t);\n\t};\n\n\tconst renderShape = (shape) => {\n\t\tctx.save();\n\t\tctx.translate(shape.x * options.worldScale, shape.y * options.worldScale);\n\t\tfor (let i = 0; i < shape.type.length; ++i) {\n\t\t\tconst row = shape.type[i];\n\t\t\tfor (let j = 0; j < row.length; ++j) {\n\t\t\t\tif (row[j]) {\n\t\t\t\t\trenderBlock(j, i, shape.color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t};\n\n\treturn (playerShapes) => {\n\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\t\tfor (let i = 0; i < playerShapes.length; ++i) {\n\t\t\tconst shapes = playerShapes[i];\n\t\t\tfor (let j = 0; j < shapes.length; ++j) {\n\t\t\t\trenderShape(shapes[j]);\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst createTicker = (t) => {\n\treturn (fn) => {\n\t\tlet enabled = true;\n\t\tconst handler = () => {\n\t\t\tif (!enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfn();\n\t\t\tsetTimeout(handler, t);\n\t\t};\n\t\tsetTimeout(handler, t);\n\t\treturn () => {\n\t\t\tenabled = false;\n\t\t};\n\t};\n};\n\nconst createGameRules = (options) => {\n\tconst doesBBoxOverlap = (s1, s2) => {\n\t\tif (\n\t\t\ts1.x > s2.x + s2.type[0].length ||\n\t\t\ts1.x + s1.type[0].length < s2.x ||\n\t\t\ts1.y > s2.y + s2.type.length ||\n\t\t\ts1.y + s1.type.length < s2.y\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\tconst doesBlockOverlap = (s1, row, col, s2) => {\n\t\tif (!s1.type[row][col]) {\n\t\t\treturn false;\n\t\t}\n\t\tconst s2row = row + s1.y - s2.y;\n\t\tconst s2col = col + s1.x - s2.x;\n\t\tif (s2.type[s2row] && s2.type[s2row][s2col]) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tconst getOtherShapes = function* (activeShape, playerShapes) {\n\t\tfor (let i = 0; i < playerShapes.length; ++i) {\n\t\t\tconst shapes = playerShapes[i];\n\t\t\tfor (let j = 0; j < shapes.length; ++j) {\n\t\t\t\tconst shape = shapes[j];\n\t\t\t\tif (shape === activeShape) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tyield [shape, j === 0];\n\t\t\t}\n\t\t}\n\t};\n\tconst isBlockedFromLeft = (simulated, activeShape, playerShapes) => {\n\t\tif (simulated.type === activeShape.type && simulated.x >= activeShape.x) {\n\t\t\treturn null;\n\t\t}\n\t\tif (simulated.x < 0) {\n\t\t\treturn RULE_ACTIONS.BLOCK_ACTION;\n\t\t}\n\t\tfor (let [shape] of getOtherShapes(activeShape, playerShapes)) {\n\t\t\tif (!doesBBoxOverlap(simulated, shape)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst col = 0;\n\t\t\tfor (let row = 0; row < simulated.type.length; ++row) {\n\t\t\t\tif (doesBlockOverlap(simulated, row, col, shape)) {\n\t\t\t\t\treturn RULE_ACTIONS.BLOCK_ACTION;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst isBlockedFromRight = (simulated, activeShape, playerShapes) => {\n\t\tif (simulated.type === activeShape.type && simulated.x <= activeShape.x) {\n\t\t\treturn null;\n\t\t}\n\t\tif (simulated.x + simulated.type[0].length > options.worldWidth) {\n\t\t\treturn RULE_ACTIONS.BLOCK_ACTION;\n\t\t}\n\t\tfor (let [shape] of getOtherShapes(activeShape, playerShapes)) {\n\t\t\tif (!doesBBoxOverlap(simulated, shape)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst col = simulated.type[0].length - 1;\n\t\t\tfor (let row = 0; row < simulated.type.length; ++row) {\n\t\t\t\tif (doesBlockOverlap(simulated, row, col, shape)) {\n\t\t\t\t\treturn RULE_ACTIONS.BLOCK_ACTION;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst isBlockedFromBottom = (simulated, activeShape, playerShapes) => {\n\t\tif (simulated.type === activeShape.type && simulated.y <= activeShape.y) {\n\t\t\treturn null;\n\t\t}\n\t\tif (simulated.y + simulated.type.length > options.worldHeight) {\n\t\t\treturn RULE_ACTIONS.CREATE_SHAPE;\n\t\t}\n\t\tfor (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)) {\n\t\t\tif (!doesBBoxOverlap(simulated, shape)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst row = simulated.type.length - 1;\n\t\t\tfor (let col = 0; col < simulated.type[0].length; ++col) {\n\t\t\t\tif (doesBlockOverlap(simulated, row, col, shape)) {\n\t\t\t\t\tif (simulated.y <= 0) {\n\t\t\t\t\t\treturn RULE_ACTIONS.END_THE_GAME;\n\t\t\t\t\t}\n\t\t\t\t\tif (isActive) {\n\t\t\t\t\t\treturn RULE_ACTIONS.BLOCK_ACTION;\n\t\t\t\t\t}\n\t\t\t\t\treturn RULE_ACTIONS.CREATE_SHAPE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\treturn [isBlockedFromLeft, isBlockedFromRight, isBlockedFromBottom];\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\tconst keymaps = [\n\t\t{\n\t\t\tKeyW: ACTION_TYPES.rotateShape,\n\t\t\tKeyA: ACTION_TYPES.moveLeft,\n\t\t\tKeyS: ACTION_TYPES.moveDown,\n\t\t\tKeyD: ACTION_TYPES.moveRight\n\t\t},\n\t\t{\n\t\t\tArrowUp: ACTION_TYPES.rotateShape,\n\t\t\tArrowLeft: ACTION_TYPES.moveLeft,\n\t\t\tArrowDown: ACTION_TYPES.moveDown,\n\t\t\tArrowRight: ACTION_TYPES.moveRight\n\t\t}\n\t];\n\n\tconst options = {\n\t\tworldWidth: 32,\n\t\tworldHeight: 16,\n\t\tworldScale: 25\n\t};\n\n\tconst canvas = document.getElementById('game-canvas');\n\tconst renderer = createRenderer(canvas, options);\n\tconst ticker = createTicker(500);\n\tconst ruleset = createGameRules(options);\n\tstartWorld(keymaps, renderer, ticker, ruleset, options);\n});\n"],"names":["$9506314bc53e323e$var$SHAPE_TYPES","$9506314bc53e323e$var$ACTION_TYPES","moveLeft","shape","x","moveRight","moveDown","y","rotateShape","type","i","length","j","$9506314bc53e323e$var$RULE_ACTIONS","BLOCK_ACTION","CREATE_SHAPE","END_THE_GAME","$9506314bc53e323e$var$startPlayer","keymap","listener","keyDownListener","e","key","Object","keys","code","document","addEventListener","removeEventListener","$9506314bc53e323e$var$startWorld","keymaps","renderer","ticker","ruleset","options","PLAYER_COLORS","playersCount","playerShapes","stopPlayerFns","requestReRender","createNewShape","index","Math","floor","random","color","worldWidth","unshift","playerActionListener","action","activeShape","simulated","create","result","ruleFn","alert","stopWorld","stopGameClock","forEach","fn","$9506314bc53e323e$var$createRenderer","canvas","canvasWidth","worldScale","canvasHeight","worldHeight","width","height","ctx","getContext","renderBlock","fillStyle","strokeStyle","fillRect","strokeRect","renderShape","save","translate","row","restore","clearRect","shapes","$9506314bc53e323e$var$createTicker","t","enabled","handler","setTimeout","$9506314bc53e323e$var$createGameRules","doesBBoxOverlap","s1","s2","doesBlockOverlap","col","s2row","s2col","getOtherShapes","isActive","KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowLeft","ArrowDown","ArrowRight","getElementById"],"version":3,"file":"embed-poc.1791db91.js.map"}